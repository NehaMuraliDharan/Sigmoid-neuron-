# -*- coding: utf-8 -*-
"""machine learning basics.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17-0mOtaU3qcHVn0jM_ltpPe472TWELET
"""



"""# Sigmoid Function"""

import numpy as np
import matplotlib.pyplot as plt 
import matplotlib.colors

def sigmoid(x,w,b):
  return 1/(1+ np.exp(-(w*x+b)))

sigmoid(1,0.5,0)

w=-0.5 #@param{type:"slider", min:-2, max:2, step:0.1}
b=-1 #@param{type:"slider", min:-2, max:2, step:0.1}
X=np.linspace(-10,10,100)
Y=sigmoid(X,w,b)

plt.plot(X,Y)



"""###Plotting sigmoid function in 3D"""

def sigmoid_3(x1,x2,w1,w2,b):
  return 1/(1+ np.exp(-(w1*x1+w2*x2+b)))

sigmoid_3(1,0,0.5,0,0)

from mpl_toolkits import mplot3d

X1=np.linspace(-10,10,100)
X2=np.linspace(-10,10,100)

XX1, XX2=np.meshgrid(X1, X2)

print(X1.shape, X2.shape, XX1.shape, XX2.shape)

w1=0.5
w2=0.5
b=0
Y=sigmoid_3(XX1, XX2, w1, w2, b)

fig=plt.figure()
ax=plt.axes(projection='3d')
ax.plot_surface(XX1, XX2, Y, cmap='viridis')
ax.set_xlabel('x1')
ax.set_ylabel('x2')
ax.set_zlabel('y')

ax.view_init(30, 270)



"""###Compute loss for the given database"""

w_unknown=0.5
b_unknown=0.25

X=np.random.random(25)*20-10
Y=sigmoid(X, w_unknown, b_unknown)
print(Y)

plt.plot(X,Y,'*')
plt.show()

def calculate_loss( X,Y, w_est, b_est):
  loss=0
  for x,y in zip(X,Y):
    loss +=(y-sigmoid(x,w_est, b_est))**2
    return loss

W=np.linspace(-1,1,100)
B=np.linspace(-1,2,100)
WW, BB=np.meshgrid(W, B)

WW.shape

Loss=np.zeros(WW.shape)
for i in range(WW.shape[0]):
  for j in range(WW.shape[1]):
    Loss[i,j]=calculate_loss(X, Y, WW[i, j], BB[i, j])

fig=plt.figure()
ax=plt.axes(projection='3d')
ax.plot_surface(WW, BB, Loss, cmap='viridis')
ax.set_xlabel('w')
ax.set_ylabel('b')
ax.set_zlabel('Loss')

#ax.view_init(30, 270)

ij=np.argmin(Loss)
i=int(np.floor(ij/Loss.shape[1]))
j= int(ij-i*Loss.shape[1])

print(i,j)

j

WW[i,j]

BB[i, j]

plt.contourf(XX1, XX2, Y, cmap=cmap)
plt.show()
cmap= matplotlib.colors.LinearSegmentedColormap.from_list("", ["violet", "blue", "black"])



"""##Class"""

class SigmoidNeuron:
  def __init__(self):
    self.w=None 
    self.b=None
  def perceptron(self, x):
    return np.dot(x, self.w.T)+ self.b 
  def sigmoid(elf, x):
    return 1.0/(1.0+ np.exp(-x))
  def grad_w(self,x,y):
    y_pred=self.sigmoid(self.perceptron(x))
    return (y_pred-y)*y_pred*(1-y_pred)*x
  def grad_b(self, x, y):
    y_pred=self.sigmoid(self.perceptron(x))
    return (y_pred-y)*y_pred*(1-y_pred)
  def fit(self, X, Y, epochs=1, learning_rate=1, initialise=True):

    #initialize w and b
    if initialise:
      self.w=np.random.randn(1, X.shape[1])
      self.b=0
    for i in range(epochs):
      dw=0
      db=0
      for x,y in zip(X,Y):
        dw+=self.grad_w(x,y)
        db+=self.grad_b(x,y)
      self.w-=learning_rate*dw
      self.b-=learning_rate*db
    def predict(self, X):
      Y_pred=[]
      for x in X:
        Y_pred=self.sigmoid(self.perceptron(x))
        Y_pred.append(y_pred)
      return np.array(Y_pred)

import numpy as np

X=np.asarray([[2.5,2.5], [4,-1], [1,-4], [3,1.25], [2,4], [1,5]])
Y=[1,1,1,0,0,0]

sn=SigmoidNeuron()
sn.fit(X,Y, 1, 0.25, True)

sn.fit(X,Y, 1, 0.25, True)
for i in range(20):
  print(sn.w, sn.b)
  sn.fit(X, Y, 1, 0.5, False)

import matplotlib.colors
cmap= matplotlib.colors.LinearSegmentedColormap.from_list("", ["violet", "blue", "black"])
def plot_sn(X,Y, sn, ax):
  X1= np.linspace(-10, 10, 100)
  X2= np.linspace(-10, 10, 100)
  XX1, XX2= np.meshgrid(X1, X2)
  YY= np.zeros(XX1.shape)
  for i in range(X2.size):
    for j in range(X1.size):
      val= np.asarray([X1[j], X2[i]])
      YY[i, j]= sn.sigmoid(sn.perceptron(val))
  ax.contourf(XX1, XX2, YY, cmap=cmap, alpha=0.6)
  ax.scatter(X[:, 0], X[:, 1], c=Y, cmap=cmap)
  ax.plot()

Y=[1,1,1,0,0,0]
sn.fit(X, Y, 1, 0.5, True)
N=20
plt.figure(figsize=(10, N*5))
for i in range(N):
  ax=plt.subplot(N, 1, i+1)
  print(sn.w, sn.b)
  plot_sn(X, Y, sn, ax)
  sn.fit(X,Y, 1, 0.5, False)



"""#Working with Real Time Data

##Loading Data
"""

import pandas as pd 
from google.colab import files

import io

uploaded = files.upload()

for fn in uploaded.keys():
  print('User uploaded file "{name}" with length {length} bytes'.format(
      name=fn, length=len(uploaded[fn])))

data=pd.read_csv(io.StringIO(uploaded['mobile_cleaned-1551253091700.csv'].decode('utf-8')))

data.shape

data.head()

X=data.drop(['Rating'], axis=1)

X.shape

Y=data['Rating']

threshold=4.2

import numpy as np
data['class']=(data['Rating']>=threshold).astype(np.int)

data['class'].values

Y_binarized=data['class'].values

Y_binarized

"""##Test Train Split and Standardization"""

from sklearn.model_selection import train_test_split

X_train, X_test, Y_train, Y_test= train_test_split(X, Y, random_state=0, stratify= Y_binarized)

from sklearn.preprocessing import StandardScaler

scalar=StandardScaler()

X_scalar_train= scalar.fit_transform(X_train)
X_scalar_test=scalar.transform(X_test)

from sklearn.preprocessing import MinMaxScaler

minmax_scaler=MinMaxScaler()

import numpy as np 
Y_train=np.array(Y_train)

Y_train=Y_train.reshape(-1, 1)

Y_scaled_train=minmax_scaler.fit_transform(Y_train)

import numpy as np 
Y_test=np.array(Y_test)
Y_test=Y_test.reshape(-1, 1)
Y_scaled_test=minmax_scaler.transform(Y_test)

scaled_threshold =list(minmax_scaler.transform(np.array([threshold]).reshape(-1, 1)))[0][0]

scaled_threshold

Y_binarized_train=(Y_scaled_train>scaled_threshold).astype("int")

Y_binarized_train.ravel()

Y_binarized_test=(Y_scaled_test>scaled_threshold).astype("int")
Y_binarized_test.ravel()

#note that we have only binarized the output (Y) until now

"""##Fitting Data"""

sn.fit(X_scalar_train, Y_binarized_train, epochs=5000, learning_rate=0.2)

Y_pred_train=sn.predict(X_scalar_train)
Y_pred_test=sn.predict(X_scalar_test)

Y_pred_binarized_train=(Y_pred_train>scaled_threshold).astype("int")
Y_pred_binarized_test=(Y_pred_test>scaled_threshold).astype("int")

